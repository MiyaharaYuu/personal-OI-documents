# 线段树

问题引入：给定 $N=10^5$ 个数，支持以下两种操作：将 $x$ 位置的数修改为 $y$，查询区间 $[l,r]$ 的和。 

在分块的做法中，我们把原序列分成若干个整块，此时每次查询共需要花费 $O(T)+O(\frac{n}{T})$ 的时间。因此，我们得到解决这一问题的可能思路：

将原序列进行一些划分，使得修改转化为修改若干个块的结果，查询转化为查询若干个块的结果，以起到减低时间复杂度的目的。

问题：如何对原序列进行合理的划分，使得每一组询问一定能够被拆分成若干个块之和？

![img](https://oi-wiki.org/ds/images/segt1.svg)

不难发现，此时，任意一个区间最多会被拆分为 $O(\log n)$ 个不重叠的极大区间。此时，只需查询这 $O(\log n)$ 区间的数据之和即可。

问题：由此看来，线段树维护的数据需要具有什么性质？

同时，也不难发现，每次我们单点修改时，只需要修改至多 $\log n$ 个区间的区间和即可。

思考：如何用代码实现查询和修改的过程？

查询：从根节点出发，若查询区间等于当前区间，则累计上当前区间的结果。

否则：

- 查询区间完全被当前区间的左儿子/右儿子包含，查询区间不变，递归的进入左儿子/右儿子。
- 查询区间横跨了当前区间的中点，则将查询区间按当前区间中点拆分为二，分别递归的进入左儿子/右儿子。

修改：从根节点出发，判断需要修改的点在当前区间的左儿子还是右儿子，如此递归直至区间长为 $1$，修改该区间，并在递归返回时一路修改。

问题：给定 $N=10^5$ 个数，支持以下两种操作：将 $[l,r]$ 全部加 $x$，查询区间 $[l,r]$ 的和。 

此时，如果我们修改操作仍每次都只修改一个点，则时间复杂度过大无法承受。

回忆：在分块时，我们的操作是？

使用**懒标记**进行修改，即，延迟对节点的修改操作。我们仍旧按照先前拆分查询区间的方法拆分修改区间，并且只对每个**极大区间**进行修改（即修改区间和）。

问题：如果要查询该极大区间的子区间的区间和，该如何保证答案正确？

我们引入一种名叫**懒标记下传**的策略。具体的，如果我们需要知道该极大区间的子区间的信息，在线段树上递归的过程中，我们必然会先访问该极大区间。此时，我们可以把该懒标记下传至当前区间的两个儿子，并清除区间的懒标记避免重复下传。

如何用代码实现该过程？

为每个节点定义懒标记，并定义懒标记下传函数用于下传懒标记。最好一并定义更新函数用于从儿子节点更新当前节点的信息。

![img](https://oi-wiki.org/ds/images/segt3.svg)

![img](https://oi-wiki.org/ds/images/segt4.svg)

https://www.luogu.com.cn/problem/P3372

问题：给定 $N=10^5$ 个数，支持以下三种操作：将 $[l,r]$ 全部加 $x$，将 $[l,r]$ 全部乘 $x$，查询区间 $[l,r]$ 的和。 

注意视操作类型的不同改变懒标记的下传顺序。

https://www.luogu.com.cn/problem/P3373

问题：给定 $N=10^5$ 个数，支持以下三种操作：将 $[l,r]$ 全部修改为 $x$，查询区间 $[l,r]$ 的和。 

https://www.luogu.com.cn/problem/P3870

问题：最大区间子段和。给定 $N=10^5$ 个数，支持以下两种操作：修改 $x$ 位置的数为 $y$，查询区间 $[l,r]$ 中子段和的最大值。子段指的是序列连续的一段。

https://www.luogu.com.cn/problem/P4513

https://www.luogu.com.cn/problem/P1471

如何实际应用线段树？

https://www.luogu.com.cn/problem/P1637

https://www.luogu.com.cn/problem/P4145