# 时间复杂度分析

## 时间复杂度的概念

时间复杂度，即描述程序所需要完成计算的次数与输入程序的数据量之间的关系的方式。简而言之，就是考察当输入大小为变量 $n$ 时，程序完成运算所需要的时间的方式。

### 记号

在信息竞赛中，所常用的只有大 $O$ 记号和 ${\Theta}$ 记号。对于 $O(f(n))$，描述程序运行的时间小于等于 $f(n)$ 的常数倍，而对于   $\Theta(f(n))$，则描述程序运行时间恰为 $f(n)$ 的常数倍。

在分析时间复杂度时，我们通常不区分以不同数作为底的对数，因为换底公式指出，这样的对数之间仅相差常数。

### 常见的时间复杂度结果和其对应的数据范围

观察到数据范围时，可以通过时间复杂度反向思考其所对应的算法。一般来说，认为计算机每秒可以进行 $10^8-10^9$ 次运算。于是，得到的可接受的时间复杂度关系如下图。

| 时间复杂度         | 数据范围            |
| ------------------ | ------------------- |
| $O(n!)$            | $10$                |
| $O(3^n)$           | $17$                |
| $O(n^32^n)$        | $18$                |
| $O(n^22^n)$        | $20$                |
| $O(n2^n)$          | $22$                |
| $O(n^4)$           | $100$               |
| $O(n^3)$           | $500-10^3$          |
| $O(n^2)$           | $5\times10^3-10^4$  |
| $O(n\log^2n)$      | $10^5$              |
| $O(n\sqrt n)$      | $10^5$              |
| $O(n\log n)$       | $5\times 10^5-10^6$ |
| $O(n \log\log n)$  | $5\times 10^6$      |
| $O(n)$             | $10^7$              |
| $O(n^\frac{2}{3})$ | $10^{11}$           |
| $O(\sqrt n)$       | $10^{14}$           |
| $O(\log n)$        | $10^{18} - $        |

### 常见的时间复杂度结果

- 循环，如下代码，时间复杂度是？

  ```c++
  int n,m;
  
  for(int i=1;i<=10;i++)
  {
  	for(int j=1;j<=n;j++)
  	{
  		for(int k=1;k+=2;k<=m;k++)
  		{
  			for(int l=1;l<=n;l+=5)
  			{
  				//
  			}
  		}
  	}
  }
  ```

  ```c++
  int n;
  
  for(int i=1;i<=n;i++)
  {
  	for(int j=1;i*j<=n;j++)
  	{
  		//
  	}
  }
  ```

  ```c++
  int n;
  
  for(int i=1;i<=n;i++)
  {
  	for(int j=i;j;j>>=1)
  	{
  		//
  	}
  }
  ```

  ```c++
  int n;
  
  for(int i=0;i<(1<<n);i++)
  {
  	for(int j=i;j;j=j&(j-1))
  	{
  		//
  	}
  }
  ```

  ```c++
  int n;
  
  for(int l=1,r;l<=n;l=r+1)
  {
  	r=n/(n/l);
      //
  }
  ```

- 递归，下列代码的时间复杂度是？

  ```c++
  int n,m; 
  
  void dfs(int x)
  {
  	//
  	vis[x]=1;
  	
  	for(int i=st[x];i;i=a[i].nxt) if(!vis[a[i].to]) dfs(a[i].to);
  }
  ```

  ```c++
  int n;
  
  void dfs(int x)
  {
  	if(x>n) return ;
      
      for(int i=1;i<=n;i++)
      {
      	if(!vis[i])
      	{
      		vis[i]=1;
      		dfs(x+1);
      	}
      }
  }
  ```

## 复杂度均摊

一些情况下，我们不能计算单次操作的复杂度，而要把多次操作的复杂度合并到一起进行计算。即，虽然单次操作可能很慢，但总体操作数不会超过某一个范围，使得原本看似不优的复杂度得到更好的结果。

- 初始有 $n$ 个节点，有三类操作：遍历全部节点；随机插入一个节点；随机选择一段连续的节点，将其合并为一个节点。假如操作数与 $n$ 同阶，试分析此时的时间复杂度。

- 序列长度为 $n$，维护两个指针 $l,r$，令 $s[l,r]=u^ku'$ 这样的形式保持， $u^k$ 代表子段 $u$ 重复出现了 $k$ 次。$u'$ 是 $u$ 的真前缀，记录 $|u|,k,|u'|$。现在考虑我们加入字符 $s[r+1]$：（当 $r+1>n$ 时视新字符为 $0$。）

  - $s[r+1]=s[r-|u|+1]$：延长 $u'$。
  - $s[r+1]>s[r-|u|+1]$：令 $s[l,r+1]$ 成为新的 $u$。
  - $s[r+1]<s[r-|u|+1]$：前推 $l$ 到 $u'$ 起始位置，并令 $r=l$。

  试分析本算法的时间复杂度。

## 势能分析

为状态定义势能函数 $F(S)$，并考察 $F(S)$ 值的变化以分析复杂度的方式。

具体问题具体分析，此处不做展开。

## 平衡复杂度

如果操作 $a$ 需要花 $O(T)$ 的时间，$b$ 需要花 $O(\frac{n}{T})$ 的时间，那么？

现在，我们有两种操作：对区间 $[l,r]$ 做一次循环位移；求 $[l,r]$ 的和。序列长度 $n=10^5$，如何尽可能快的解决这个问题？

## 常数

尽管在分析时间复杂度时我们不考虑常数的影响，但在实际代码实现过程中，常数也会极大的左右程序的运行效率，亦在需要考虑的范围之内。

- 读入优化：当读入量超过 $10^6$ 个数时，请在代码前方添加：

  ```c++
  ios::sync_with_stdio(0);
  ```

- 运算：通常来说，位运算的速度快于四则运算的速度，且远快于取模的速度。在代码中尽量减少取模是有必要的。一个可能的改写是：

  ```c++
  a=(b+c)%mod;
  ```

  换为

  ```c++
  a=b+c;
  b+c>=mod ? a-=mod : 1;
  ```

  注意，这要求 $b,c\le mod$。

