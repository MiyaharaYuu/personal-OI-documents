# 图论基础



## 图与树

### 图的定义

- 图由一个二元组，即两个集合进行定义，分别是图的点集（```Vertex```）和边集（```Edge```），其中，点集应当非空。下给出一个典型的例子。

  ![graph](C:\Users\chenzehua\Downloads\graph.png)

- 在上图中，点集 $\mathbb{E}=\{1,2,3,4,5\}$，边集 $\mathbb{V}=\{(1,2),(2,3),(3,4),(2,5).(1.4)\}$。注意边集中的元素为一个个二元组。当这些二元组无序时，称图为无向图，当其有序时，称其为有向图。

- 通常，我们用 $x$ 抽象的指代图中的单点，用 $(u,v)$ 抽象的指代图中的一条边，而 $u,v$ 则为该边的端点。当图有向时，称 $u$ 为边 $(u,v)$ 的起点，$v$ 为终点。

- 图的连通性，图上的路径的定义和环的定义都是自然的。通常，我们所讨论的图为无向图。

- 图上点的度数的定义是自然的，对于有向图，存在点的入度和出度。

- 图的子图的定义是自然的。

- 对于端点相同的边，通常称其为自环。（尽管并不严格符合集合的定义，但我们可以通过对每条边编号使其唯一。）对于端点重合的两条边，通常称其为重边。

- 为点附加点权，为边附加边权是自然的。

- 习惯上，记 $n$ 为图的点集大小，$m$ 为图的边集大小。

### 树的定义

- 称满足 $|V|=|E|+1$ 的连通图为树。
- 性质：任意两点之间路径存在且唯一（即无环）。
- 通常而言，树的边是无向的。
- 可以定义树的某一点为树的根，此时称这样的树为有根树。我们通常所讨论的树均为有根树。
- 从树的根出发到某一点的路径上的所有点均是该点的祖先，而距离该点最近的祖先称作该点的父亲。该点是其所有祖先的后代，是其父亲的儿子。任意一点的所有后代组成这一点的子树（包括这点自身），显然子树是一个联通块，且除去该点自身外不会包含该点的任何祖先。
- 记从根到某点路径上的节点数为该节点的深度。
- 对于树上两点 $u,v$，记 $\mathrm{LCA}(u,v)$ 为这两点公共祖先组成的集合。该集合中深度最大的一点记为这两点的最近公共祖先。
- 链、菊花图、二叉树等定义是形象且自然的。

### 图的存储

- 一种最朴素的存储方式。

  ```c++
  int a[MAXN][MAXN];
  
  for(int i=1;i<=n;i++) a[x][i] 
  ```

  此时，如果我们想找到一个点的所有边，所需要的时间是 $n$ 次运算。遍历整张图则需要 $n^2$ 次运算。当 $m << n^2$ 时，产生了极大的时间浪费。

- 一种更好的存储方式。

- 一种非常好的存储方式。邻接表。

  ```c++
  int n;
  int fa[MAXN],siz[MAXN],st[MAXN],cnt=0;
  
  struct line
  {
  	int to,nxt;
  } a[MAXN*2];
  
  void add(int x,int y)
  {
  	a[++cnt].to=y;
  	a[cnt].nxt=st[x];
  	st[x]=cnt;
  }
  ```

  思考：如何遍历？

- 思考：邻接表相较于 ```vector``` 有何缺点/不便之处？

## 图的遍历

对于连通图而言，从某个点触发，允许重复经过点与边，我们总可以遍历整张图。区别只在于方式。

### 深度优先搜索（```DFS```）

- 理解：从我们指定的一点出发，除非走到死路否则不回头。

  ```c++
  void dfs(int x)
  {
  	for(int i=st[x];i;i=a[i].nxt)
  	 dfs(a[i].to);
  }
  ```

- 这段代码的问题？

- 应用：寻找联通块。走迷宫的过程？

### 广度优先搜索（```BFS```）

- 理解：从我们指定的一点出发，以到这些点的距离将图分层。先遍历距离为一的点……

  ```c++
  queue<int> mov;
  int vis[MAXN];
  
  while(!mov.empty())
  {
  	x=a.front(),mov.pop();
  	for(int i=st[x];i;i=a[i].nxt) if(!vis[a[i].to]) mov.push(a[i].to);
  }
  ```

### 练习A

https://www.luogu.com.cn/problem/P5318

https://www.luogu.com.cn/problem/P3916

https://www.luogu.com.cn/problem/P1363

https://www.luogu.com.cn/problem/P5908

### 抽象的图

状态也可以视为图，把每个状态视作点，若状态 ```A``` 可以抵达 ```B```，则可以认为两者之间有边。

### 练习B

https://www.luogu.com.cn/problem/P1219

https://www.luogu.com.cn/problem/P1443

https://www.luogu.com.cn/problem/P2404

https://www.luogu.com.cn/problem/P1379

### 树的遍历

现在，我们希望讨论一类特殊的树：二叉树的遍历。

- 前序遍历：每到达一个节点时，操作该节点，并依次前序遍历其左儿子和右儿子。
- 中序遍历：每到达一个节点时，前序遍历其左儿子，操作该节点，前序遍历其右儿子。
- 后序遍历：每到达一个节点时，依次前序遍历其左儿子和右儿子，操作该节点。

我们应当如何实现呢？

https://www.luogu.com.cn/problem/B3642

## 图的算法

### 单源最短路径

- 问题：求从某个点出发，任意一点到其的距离最小值。图上所有边权为正。
- 思路：想想在什么情况下，我们能确定到某个点的距离已经是最短的？
- https://www.luogu.com.cn/problem/P4779

### 最小生成树

- 问题：生成树是原图的一个子图，满足其点集和原图相同，且构成一棵树。最小生成树即生成树中边集权值和最小的一个。求出这棵生成树的每一条边。假定我们可以在常数时间内判断任意两点是否相连。
- 思路：直接贪心可以吗？

### 树的直径

- 问题：求出树上最长的一条路径。
- 思路：直径具有怎样的性质？
- 思考：树的多条直径之间？
- https://www.luogu.com.cn/problem/P3304

### 树的重心

- 问题：求出树上的一点，满足该点的所有子树的大小的最大值最小。
- 思考：
  - 树最多有几个重心？它们有什么关系？
  - 树的重心的子树大小有什么性质？
  - 树的重心到树上所有点的距离和有何性质？
- https://www.luogu.com.cn/problem/P1395

### 拓扑排序

- 问题：对一张有向无环图，构建一个序列。满足按该序列删去图上的点时，删去的点的入度总为零。
- 思路：这样的序列一定存在吗？为什么？
- https://www.luogu.com.cn/problem/B3644
