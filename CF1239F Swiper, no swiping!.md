

## CF1239F Swiper, no swiping!

### 题目描述

给定一张 $$n$$ 个点， $$m$$ 条边的无重边自环无向连通图，删除一个非空且非全集的点集，使剩下所有点的点度在 $\text{mod} \ 3$ 意义下不变。或报告无解。

多组询问， $\sum n,\sum m \le 5\times 10^5$，3s。

### 提示

考察特殊情况。

### 解法

分类讨论，尝试从简单的情况入手。以下点度均在模 $3$ 意义下讨论。

- 存在 $0$ 度点。

  简单的情况，仅保留该点即可。

- 存在至少两个 $1$ 度点。

  此时图上不存在 $0$ 度点，直接拉出一条从 $1$ 度点出发到 $1$ 度点的路径，当路径内部无边且不经过重复点，且路径上所有点均为 $2$ 度点时，仅保留路径是合法的。

  找出这样的路径是容易的，直接考虑从任意一个 $1$ 度点出发，寻找其走到另一个 $1$ 度点的最短路即可。

- 存在 $2$ 度点形成的环

  保留内部无边的这样的环是合法的，考虑对原图随意求出一棵 DFS 树，那么由返祖边和树边组成的最小环一定合法。

- 其他情况

  现在图为若干个 $2$ 度点森林，以及至多一个 $1$ 度点。

  注意到 $1$ 度点的存在性必然，考虑森林叶子即可，容易发现，此时所有叶子都和 $1$ 度点相邻，且 $1$ 度点点度至少为 $4$。

  那么考虑构造从某个 $2$ 度叶子出发，走到另一个 $2$ 度叶子，走到 $1$，走到另一棵树的 $2$ 度叶子，再按类似的方式走回 $1$ 的环路，容易证明这样是合法的。

  问题的关键在于，是否一定有两棵树存在？答案是确定的。当只有一棵树时，考虑共有 $k$ 个 $2$ 度点，那么树的度数和同余 $2k$，又注意到树内共有 $k-1$ 条边，即 $2k-2$ 的点度，那么 $1$ 度点上的点度为 $2k-2k+2 \equiv 2\pmod 2$，这导出矛盾。

  现在，我们只需判断构造出的路径是否是全集本身即可。

## [CCO2020] Shopping Plans

### 题目描述

商店里有 $n$ 个物品，每个物品有两种属性：种类和价格。对第 $i$ 个种类，需要购买的物品数量介于 $[l_i,r_i]$ 中，请给出价格前 $k$ 小的方案，或报告无解。

$n,m,k \le 2\times 10^5$，2s。

### 解法

尝试从简单的情况得出复杂情况的解法。

我们尝试建立起一套系统：我们每次取出一个最优解，并加入若干次优解，我们只需保证这个系统可以统计所有的合法情况，并且保证一个最优解的后继一定都劣于自己即可。

-  $m=1$ 的情况

  最优解显然是选择价格最小的 $l$ 个物品。

  考虑 $l=r$ 的情况，这时，我们的转移可以为，每次将最左的其右侧物品未被选择的物品右移若干位，保证其不跨过其他已经被选择的物品。但，此时每步操作新增的转移数可能是 $O(n)$ 的，我们考虑降低后继数量。

  观察我们所获得的某个状态，不难注意到，其可以由"将序列中某个连续前缀的末端右移若干位"得到，而右移若干位可以拆解为连续操作右移一位。因而，不妨扩充状态，增加“当前选中的物品“这一维度，把我们的转移变为：

  - 将当前选中的物品右移一位。
  - 将当前选中的物品切换为连续前缀的末尾，将其右移一位。

  本转移和前文所述转移的等价性是容易验证的。

  当 $l\ne r$ 时，转移起点仍然为前 $l$ 个物品，只需要给所有形如 $[1,i]$ 的状态增加向 $[1,i+1]$ 的转移即可。

- 任意 $i$，$l_i=r_i=1$ 的情况

  最优解显然是任何物品均只选择一个。

  类似的，我们扩充状态，增加一个维度来表示当前所聚焦的物品种类。那么简单的，我们得到以下转移：将当前种类所选的物品右移一位，再抉择是否把当前所选物品种类后移若干位，再将所选物品右移一位。容易验证这样的转移也是唯一的，然而每次新增的转移数量仍旧可能很大。

  此时，我们不妨想办法将每个节点可能的转移排序。我们实际上在做这样一件事：从起始状态开始，从上当下，依次抉择本行是否移动和移动多少。而在这一过程中，实际上我们需要枚举下一个操作的行和本行之间的间隔。因此，为了缩减转移数，我们希望按照合理的顺序进行转移，使得转移时只需要考虑这一行下一个相邻的行。

  那么我们的转移需要达到跳过某一行的目的。

  考虑在我们操作某个种类时，第一步一定是将最小值移动为次小值。对种类按照次小值和最小值的差从小到大排序，则转移为：

  - 将当前种类的选择右移。
  - 将当前所选种类后移，并右移一位（注意，这一位右移一定是从最小值到次小值的）
  - 若当前种类选择次小值，那么改为选择最小值，并执行第二类转移。

  其中第三个操作被我们用于执行跳过操作。由于我们进行了排序，那么答案的不降是有保障的。

- 原题目情况

  容易发现，我们需要进行的行为是将上述两类特殊情况进行拼合。在第二类情况中，我们其实并不关系每个种类内部的转移方式，我们只关心最小值和次小值的差，而在第一类情况中，我们可以用 $O(\log n)$ 的时间完成单一种类中的转移。因此，我们只需将第二类情况中，处理种类内部的转移时套用第一类情况的解法即可。最终时间复杂度 $O(n\log n)$。